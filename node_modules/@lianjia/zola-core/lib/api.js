const config = require('./config')
const deepMerge = require('./utils/deepMerge')
const getType = require('./utils/getType')
const objectForEach = require('./utils/objectForEach')
const ajaxRequest = require('./utils/ajax')
const jsonpRequest = require('./utils/jsonp')
const assert = require('./utils/assert')

module.exports = defaultConfigCreater => {

  const configCreaters = {}
  const self = {}
  function setConfigCreater (type, configCreater) {
    configCreaters[type] = configCreater
    const configs = getConfig(configCreaters)

    let keyMaps = {}
    objectForEach(configs,
      map => objectForEach(map, (_, name) => keyMaps[name] = name)
    )
    keyMaps = objectForEach(keyMaps,
      (_, name) => objectForEach(configs, map => map[name] || {})
    )

    const apis = objectForEach(keyMaps, config => makeRequest(config))
    return Object.assign(self, apis, { set: setConfigCreater })
  }

  return setConfigCreater('default', defaultConfigCreater)
}

function makeRequest (apiConfigs) {
  return (data, option = {}) => {

    const env = config.get('env')
    const apiConfig = apiConfigs[env] || {}

    let {
      base = '/',
      uri = '',
      method = 'GET',
      headers = {},
      credentials = 'include',
      contentType = 'x-www-form-urlencoded',
      mode = 'same-origin',
      redirect = 'follow',
      responseType = 'json',
      jsonp = false,
      requestHandler = defaultRequestHandler,
      responseHandler = defaultReponseHandler
    } = apiConfig

    if (base[base.length -1] !== '/') base += '/'
    if (uri[0] === '/') uri = uri.substring(1)
    uri = base + uri

    if (jsonp !== false) {
      const callbackHandler = getType(jsonp) === 'string' ? jsonp : 'jsonp'
      return jsonpRequest({
        uri, responseType, callbackHandler,
        data,
        query: option.query,
        uriReplacer: option.uriReplacer
      }).then(responseHandler.bind(apiConfig))
    } else {
      return ajaxRequest({
        uri, method, credentials, contentType,
        mode, redirect, responseType,
        data,
        query: option.query,
        uriReplacer: option.uriReplacer,
        headers: Object.assign({}, headers, option.headers)
      }).then(responseHandler.bind(apiConfig))
    }
  }
}


function getConfig (configCreaters) {

  if (configCreaters.default === undefined) {
    configCreaters = { default: configCreaters }
  }

  // 默认环境配置
  const {
    configMap: defaultConfigMap,
    baseConfig: defaultBaseConfig
  } = createConfig(configCreaters.default)

  return objectForEach(configCreaters, (configCreater, env) => {
    // 特殊环境配置
    const {
      configMap: envConfigMap,
      baseConfig: envBaseConfig
    } = env === 'default' || createConfig(configCreater)

    const baseConfig = deepMerge({}, defaultBaseConfig, envBaseConfig)
    const configMap = deepMerge({}, defaultConfigMap, envConfigMap)

    const configs = objectForEach(configMap, config => {
      return deepMerge( {}, baseConfig, config )
    })
    return configs
  })
}

function createConfig (fn) {
  if (getType(fn) !== 'function')
    return { configMap: null, baseConfig: null }

  // 类型检查器
  const typeCheckers = {
    string: getType.checker('string'),
    number: getType.checker('number'),
    boolean: getType.checker('boolean'),
    array: getType.checker('array'),
    object: getType.checker('object'),
    any: getType.checker()
  }

  // 处理 api config 解析
  const configMap = {}
  const api = (name, apiConfig) => {
    // 重复检查
    assert(name in configMap, 'API named with "%s" is existed.', name)
    configMap[name] = apiConfig
  }

  fn(Object.assign(api, {
    type: typeCheckers,  // 类型检查器
    config: {}           // 存放默认值
  }))
  return { configMap, baseConfig: api.config }
}

function defaultRequestHandler (request) { return request }
function defaultReponseHandler (body) {
  const { codeKey, dataKey, messageKey, successCode } = this
  const { [codeKey]: code, [dataKey]: data, [messageKey]: message } = body
  // 检查 code
  const error = assert.assertError(code !== successCode,
    'api response code error(%s)', code)

  if (error) throw Object.assign(error, {
    code, data, message: message || error.message
  })
  return data
}