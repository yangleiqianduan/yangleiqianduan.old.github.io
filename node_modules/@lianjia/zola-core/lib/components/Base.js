const React = require('react')
const getType = require('../utils/getType')
const inherit = require('../utils/inherit')

module.exports = inherit('Base', React.PureComponent, {
  // 自绑定方法
  bindSelf (...functionNames) {
    functionNames.forEach( name => this[name] = this[name].bind(this) )
  },

  // 可取消 function 或者 promise
  cancelable (name, functionOrPromise, context) {
    if (getType(name) !== 'string') {
      context = functionOrPromise
      functionOrPromise = name
      name = '*'
    }
    let canceled = false
    const cancel = () => canceled = true

    this._cancelable = this._cancelable || {}
    this._cancelable[name] = this._cancelable[name] || []
    const cancelables = this._cancelable[name]
    cancelables.push( cancel )

    if ( getType(functionOrPromise) === 'function' ) {
      return function cancelable () {
        if (canceled) return
        return functionOrPromise.apply(context, arguments)
      }
    } else if (
      getType(functionOrPromise) === 'object' &&
      getType(functionOrPromise.then) === 'function'
    ) {
      return functionOrPromise.then(result => {
        if (canceled) return Promise.reject(Object.assign(
          new Error('canceled'), {canceled: true}
        ))
        return result
      })
    }
    return () => {
      const index = cancelables.indexOf(cancel)
      if (index >= 0) cancelables.splice(index, 1)
    }
  },

  cancel (name = '*') {
    if (!this._cancelable) return
    for ( let cancel of this._cancelable[name] || [] ) cancel()
    this._cancelable[name].length = []
  },

  cancelAll () {
    if (!this._cancelable) return
    for (let name in this._cancelable ) this.cancel(name)
  },

  setTimeout (fn, delay) {
    this._setTimeout = this._setTimeout || []
    const count = setTimeout(fn, delay)
    this._setTimeout.push(count)
    return count
  },
  setTimeoutAsync (delay) {
    return new Promise(resolve => this.setTimeout(resolve, delay))
  },
  setInterval (fn, delay) {
    this._setInterval = this._setInterval || []
    const count = setInterval(fn, delay)
    this._setInterval.push(count)
    return count
  },
  componentWillMount () {},
  componentDidMount () {},
  componentWillReceiveProps () {},
  componentWillUnmount () {
    if (this._setTimeout) {
      this._setTimeout.forEach(count => clearTimeout(count))
      this._setTimeout.length = 0
    }
    if (this._setInterval) {
      this._setInterval.forEach(count => clearInterval(count))
      this._setInterval.length = 0
    }
    this.cancelAll()
  },
  componentWillUpdate () {},
  componentDidUpdate () {},
})