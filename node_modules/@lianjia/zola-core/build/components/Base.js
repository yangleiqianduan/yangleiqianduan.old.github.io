'use strict';

var React = require('react');
var getType = require('../utils/getType');
var inherit = require('../utils/inherit');

module.exports = inherit('Base', React.PureComponent, {
  // 自绑定方法
  bindSelf: function bindSelf() {
    var _this = this;

    for (var _len = arguments.length, functionNames = Array(_len), _key = 0; _key < _len; _key++) {
      functionNames[_key] = arguments[_key];
    }

    functionNames.forEach(function (name) {
      return _this[name] = _this[name].bind(_this);
    });
  },


  // 可取消 function 或者 promise
  cancelable: function cancelable(name, functionOrPromise, context) {
    if (getType(name) !== 'string') {
      context = functionOrPromise;
      functionOrPromise = name;
      name = '*';
    }
    var canceled = false;
    var cancel = function cancel() {
      return canceled = true;
    };

    this._cancelable = this._cancelable || {};
    this._cancelable[name] = this._cancelable[name] || [];
    var cancelables = this._cancelable[name];
    cancelables.push(cancel);

    if (getType(functionOrPromise) === 'function') {
      return function cancelable() {
        if (canceled) return;
        return functionOrPromise.apply(context, arguments);
      };
    } else if (getType(functionOrPromise) === 'object' && getType(functionOrPromise.then) === 'function') {
      return functionOrPromise.then(function (result) {
        if (canceled) return Promise.reject(Object.assign(new Error('canceled'), { canceled: true }));
        return result;
      });
    }
    return function () {
      var index = cancelables.indexOf(cancel);
      if (index >= 0) cancelables.splice(index, 1);
    };
  },
  cancel: function cancel() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '*';

    if (!this._cancelable) return;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (this._cancelable[name] || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var cancel = _step.value;
        cancel();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    this._cancelable[name].length = [];
  },
  cancelAll: function cancelAll() {
    if (!this._cancelable) return;
    for (var name in this._cancelable) {
      this.cancel(name);
    }
  },
  setTimeout: function (_setTimeout) {
    function setTimeout(_x2, _x3) {
      return _setTimeout.apply(this, arguments);
    }

    setTimeout.toString = function () {
      return _setTimeout.toString();
    };

    return setTimeout;
  }(function (fn, delay) {
    this._setTimeout = this._setTimeout || [];
    var count = setTimeout(fn, delay);
    this._setTimeout.push(count);
    return count;
  }),
  setTimeoutAsync: function setTimeoutAsync(delay) {
    var _this2 = this;

    return new Promise(function (resolve) {
      return _this2.setTimeout(resolve, delay);
    });
  },
  setInterval: function (_setInterval) {
    function setInterval(_x4, _x5) {
      return _setInterval.apply(this, arguments);
    }

    setInterval.toString = function () {
      return _setInterval.toString();
    };

    return setInterval;
  }(function (fn, delay) {
    this._setInterval = this._setInterval || [];
    var count = setInterval(fn, delay);
    this._setInterval.push(count);
    return count;
  }),
  componentWillMount: function componentWillMount() {},
  componentDidMount: function componentDidMount() {},
  componentWillReceiveProps: function componentWillReceiveProps() {},
  componentWillUnmount: function componentWillUnmount() {
    if (this._setTimeout) {
      this._setTimeout.forEach(function (count) {
        return clearTimeout(count);
      });
      this._setTimeout.length = 0;
    }
    if (this._setInterval) {
      this._setInterval.forEach(function (count) {
        return clearInterval(count);
      });
      this._setInterval.length = 0;
    }
    this.cancelAll();
  },
  componentWillUpdate: function componentWillUpdate() {},
  componentDidUpdate: function componentDidUpdate() {}
});