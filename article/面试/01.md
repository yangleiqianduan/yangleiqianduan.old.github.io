---
title: React 常见的面试题
categories: EDIT
tags: 面试题
creatTime: 1501806493289
---

# 在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用

## 当你调用setState的时候，发生了什么事？

当调用 `setState` 时，React会做的第一件事情是将传递给 `setState` 的对象合并到组件的当前状态。这将启动一个称为和解（reconciliation）的过程。和解（reconciliation）的最终目标是以最有效的方式，根据这个新的状态来更新UI。 为此，React将构建一个新的 `React` 元素树（您可以将其视为 UI 的对象表示）。

一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React 会将这个新树与上一个元素树相比较（ **diff** ）。

通过这样做， React 将会知道发生的确切变化，并且通过了解发生什么变化，只需在绝对必要的情况下进行更新即可最小化 UI 的占用空间。

## 在 React 当中 Element 和 Component 有何区别？

简单地说，一个 **React element** 描述了你想在屏幕上看到什么。换个说法就是，一个 **React element** 是一些 UI 的对象表示。

一个 **React Component** 是一个函数或一个类，它可以接受输入并返回一个 **React element** t（通常是通过 JSX ，它被转化成一个 createElement 调用）。

有关更多信息，请查看 [React Elements vs React Components](https://tylermcginnis.com/react-elements-vs-react-components/)

## 什么时候在功能组件( Class Component )上使用类组件( Functional Component )？

如果您的组件具有状态( state )或生命周期方法，请使用 Class 组件。否则，使用功能组件

## 什么是 React 的 refs ，为什么它们很重要？

refs就像是一个逃生舱口，允许您直接访问DOM元素或组件实例。为了使用它们，您可以向组件添加一个 **ref** 属性，该属性的值是一个回调函数，它将接收底层的 DOM 元素或组件的已挂接实例，作为其第一个参数。

<div>

<div>

<pre class="prettyprint">class UnControlledForm extends Component {
  handleSubmit = () => {
    console.log("Input Value: ", this.input.value)
  }
  render () {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          type='text'
          ref={(input) => this.input = input} />
        <button type='submit'>Submit</button>
      </form>
    )
  }
}
</pre>

</div>

</div>

以上注意到我们的输入字段有一个 **ref** 属性，其值是一个函数。该函数接收我们然后放在实例上的实际的 DOM 元素，以便在 _handleSubmit_ 函数内部访问它。经常误解的是，您需要使用类组件才能使用 **ref** ，但 **ref** 也可以通过利用 `JavaScript` 中的 **闭包** 与 功能组件( functional components )一起使用。

<div>

<div>

<pre class="prettyprint">function CustomForm ({handleSubmit}) {
  let inputElement
  return (
    <form onSubmit={() => handleSubmit(inputElement.value)}>
      <input
        type='text'
        ref={(input) => inputElement = input} />
      <button type='submit'>Submit</button>
    </form>
  )
}
</pre>

</div>

</div>

## React 中的keys是什么，为什么它们很重要？

keys是什么帮助 React 跟踪哪些项目已更改、添加或从列表中删除。

<div>

<div>

<pre class="prettyprint">  return (
    <ul>
      {this.state.todoItems.map(({task, uid}) => {
        return <li key={uid}>{task}</li>
      })}
    </ul>
  )
}
</pre>

</div>

</div>

每个 **keys** 在兄弟元素之间是独一无二的。我们已经谈过几次关于和解（reconciliation）的过程，而且这个和解过程（reconciliation）中的一部分正在执行一个新的元素树与最前一个的差异。 **keys** 使处理列表时更加高效，因为 React 可以使用子元素上的 **keys** 快速知道元素是新的还是在比较树时才被移动。

而且 **keys** 不仅使这个过程更有效率，而且没有 **keys** ，React 不知道哪个本地状态对应于移动中的哪个项目。所以当你 map 的时候，不要忽略了 **keys** 。

## 看下面的代码: 如果您在 <twitter>下创建了一个 React 元素， <twitter>的组件定义将如何？</twitter></twitter>

<div>

<div>

<pre class="prettyprint"><Twitter username='tylermcginnis33'>
  {(user) => user === null
    ? <Loading />
    : <Badge info={user} />}
</Twitter>
</pre>

</div>

</div>

<div>

<div>

<pre class="prettyprint">import React, { Component, PropTypes } from 'react'
import fetchUser from 'twitter'
// fetchUser接收用户名返回 promise
// 当得到 用户的数据的时候 ，返回resolve 状态

class Twitter extends Component {
  // 在这里写下你的代码
}
</pre>

</div>

</div>

如果你不熟悉渲染回调模式（render callback pattern），这将看起来有点奇怪。在这种模式中，一个组件接收一个函数作为它的 child。注意上面包含在 <twitter>标签内的内容。 _Twitter_ 组件的 child 是一个函数，而不是你曾经习以为常的一个组件。 这意味着在实现 _Twitter_ 组件时，我们需要将 _props.children_ 作为一个函数来处理。</twitter>

以下是我的答案。

<div>

<div>

<pre class="prettyprint">import React, { Component, PropTypes } from 'react'
import fetchUser from 'twitter'

class Twitter extends Component {
  state = {
    user: null,
  }
  static propTypes = {
    username: PropTypes.string.isRequired,
  }
  componentDidMount () {
    fetchUser(this.props.username)
      .then((user) => this.setState({user}))
  }
  render () {
    return this.props.children(this.state.user)
  }
}
</pre>

</div>

</div>

值得注意的是，正如我上面提到的，我通过调用它并传递给 user 来把 props.children 处理为为一个函数。

这种模式的好处是我们已经将我们的父组件与我们的子组件分离了。父组件管理状态，父组件的消费者可以决定以何种方式将从父级接收的参数应用于他们的 UI。

为了演示这一点，我们假设在另一个文件中，我们要渲染一个 _Profile_ 而不是一个 _Badge,_ ，因为我们使用渲染回调模式，所以我们可以轻松地交换 UI ，而不用改变我们对父（Twitter）组件的实现。

<div>

<div>

<pre class="prettyprint"><Twitter username='tylermcginnis33'>
  {(user) => user === null
    ? <Loading />
    : <Profile info={user} />}
</Twitter>
</pre>

</div>

</div>

## 受控组件( controlled component )与不受控制的组件( uncontrolled component )有什么区别？

React 的很大一部分是这样的想法，即组件负责控制和管理自己的状态。

当我们将 native HTML 表单元素（ input, select, textarea 等）投入到组合中时会发生什么？我们是否应该使用 React 作为“单一的真理来源”，就像我们习惯使用React一样？ 或者我们是否允许表单数据存在 DOM 中，就像我们习惯使用HTML表单元素一样？ 这两个问题是受控（controlled） VS 不受控制（uncontrolled）组件的核心。

受控组件是React控制的组件，也是表单数据的唯一真理来源。

如下所示， _username_ 不存在于 DOM 中，而是以我们的组件状态存在。每当我们想要更新 _username_ 时，我们就像以前一样调用setState。

<div>

<div>

<pre class="prettyprint">class ControlledForm extends Component {
  state = {
    username: ''
  }
  updateUsername = (e) => {
    this.setState({
      username: e.target.value,
    })
  }
  handleSubmit = () => {}
  render () {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          type='text'
          value={this.state.username}
          onChange={this.updateUsername} />
        <button type='submit'>Submit</button>
      </form>
    )
  }
}
</pre>

</div>

</div>

不受控制( uncontrolled component )的组件是您的表单数据由 DOM 处理，而不是您的 React 组件。

我们使用 **refs** 来完成这个。

<div>

<div>

<pre class="prettyprint">class UnControlledForm extends Component {
  handleSubmit = () => {
    console.log("Input Value: ", this.input.value)
  }
  render () {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          type='text'
          ref={(input) => this.input = input} />
        <button type='submit'>Submit</button>
      </form>
    )
  }
}
</pre>

</div>

</div>

虽然不受控制的组件通常更容易实现，因为您只需使用引用从DOM获取值，但是通常建议您通过不受控制的组件来支持受控组件。

主要原因是受控组件 **支持即时字段验证** ，允许您有条件地禁用/启用按钮，强制输入格式，并且更多的是 『the React way』。

## 在哪个生命周期事件中你会发出 AJAX 请求，为什么？

AJAX 请求应该在 `componentDidMount` 生命周期事件中。 有几个原因:

*   Fiber，是下一次实施React的和解算法，将有能力根据需要启动和停止渲染，以获得性能优势。其中一个取舍之一是 `componentWillMount` ，而在其他的生命周期事件中出发 AJAX 请求，将是具有 “非确定性的”。 这意味着 React 可以在需要时感觉到不同的时间开始调用 componentWillMount。这显然是AJAX请求的不好的方式。

-您不能保证在组件挂载之前，AJAX请求将无法 resolve。如果这样做，那意味着你会尝试在一个未挂载的组件上设置 StState，这不仅不会起作用，反而会对你大喊大叫。 在 `componentDidMount` 中执行 AJAX 将保证至少有一个要更新的组件。

## shouldComponentUpdate 应该做什么，为什么它很重要？

上面我们讨论了 reconciliation ，什么是 React 在 setState 被调用时所做的。在生命周期方法 shouldComponentUpdate 中，允许我们选择退出某些组件（和他们的子组件）的 reconciliation 过程。

我们为什么要这样做？

如上所述，“和解（ reconciliation ）的最终目标是以最有效的方式，根据新的状态更新用户界面”。如果我们知道我们的用户界面（UI）的某一部分不会改变，那么没有理由让 React 很麻烦地试图去弄清楚它是否应该渲染。通过从 shouldComponentUpdate 返回 false，React 将假定当前组件及其所有子组件将保持与当前组件相同。

## 您如何告诉React 构建（build）生产模式，该做什么？

通常，您将使用Webpack的 _DefinePlugin_ 方法将 **NODE_ENV** 设置为 production。这将剥离像 propType 验证和额外的警告。除此之外，还有一个好主意，可以减少你的代码，因为React使用 Uglify 的 dead-code 来消除开发代码和注释，这将大大减少你的包的大小。

为什么要使用 React.Children.map（props.children，（）=>） 而不是 props.children.map（（）=>）

因为不能保证props.children将是一个数组。

以此代码为例，

<div>

<div>

<pre class="prettyprint"><Parent>
  <h1>Welcome.</h1>
</Parent>
</pre>

</div>

</div>

在父组件内部，如果我们尝试使用 props.children.map 映射孩子，则会抛出错误，因为 props.children 是一个对象，而不是一个数组。

如果有多个子元素，React 只会使props.children成为一个数组。就像下面这样：

<div>

<div>

<pre class="prettyprint"><Parent>
  <h1>Welcome.</h1>
  <h2>props.children will now be an array</h2>
</Parent>
</pre>

</div>

</div>

这就是为什么你喜欢 `React.Children.map` ，因为它的实现考虑到 `props.children` 可能是一个数组或一个对象。

## 描述事件在React中的处理方式。

为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 `SyntheticEvent` 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。

这些 `SyntheticEvent` 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新DOM时，React 不需要担心跟踪事件监听器。

## createElement 和 cloneElement 有什么区别？

createElement 是 JSX 被转载到的，是 React 用来创建 React Elements 的内容(一些 UI 的对象表示)cloneElement用于克隆元素并传递新的 props。他们钉住了这两个��的命名。

## 可以选择性地传递给 setState 的第二个参数是什么，它的目的是什么？

一个回调函数，当setState结束并 `re-rendered` 该组件时将被调用。一些没有说出来的东西是 setState 是 **异步** 的，这就是为什么它需要一个第二个回调函数。通常最好使用另一个生命周期方法，而不是依赖这个回调函数，但是很高兴知道它存在。

<div>

<div>

<pre class="prettyprint">this.setState(
  { username: 'tylermcginnis33' },
  () => console.log('setState has finished and the component has re-rendered.')
)
</pre>

</div>

</div>

## 这段代码有什么问题？

<div>

<div>

<pre class="prettyprint">this.setState((prevState, props) => {
  return {
    streak: prevState.streak + props.count
  }
})
</pre>

</div>

</div>

没毛病。但是这种写法很少被使用，并不是众所周知的，就是你也可以传递一个函数给setState，它接收到先前的状态和道具并返回一个新的状态，正如我们在上面所做的那样。它不仅没有什么问题，而且如果您根据以前的状态（state）设置状态，推荐使用这种写法。

<div class="article_social">

<div id="share_weixin_image">![](http://s.jiathis.com/qrcode.php?url=http://www.tuicool.com/articles/fqaqqmF?via=wechat_qr)</div>

<div class="article_share_fav">

<div class="share" id="ckepop"><span>分享</span></div>

<div class="fav_correct"><button id="my_fav" data_id="fqaqqmF"><span id="fav_tip">收藏</span></button> <button id="article-correct" data_id="fqaqqmF" uid="0"><span>纠错</span></button></div>

</div>

<script type="text/javascript">$("#share_weibo_id").click( function() { window.open("http://share.baidu.com/s?type=text&searchPic=0&sign=on&to=tsina&url=http://www.tuicool.com/articles/fqaqqmF&title=React+%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E5%9C%A8+React+%E9%87%8C%E9%9D%A2%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E7%9F%A5%E9%81%93%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%2C+%E4%BD%86%E6%98%AF%E4%BD%A0%E4%BC%9A%E5%8F%91%E7%8E%B0%E4%BB%96%E4%BB%AC%E7%A1%AE%E5%AE%9E%E5%BE%88%E6%9C%89%E7%94%A8%EF%BC%89++%28%E5%88%86%E4%BA%AB%E8%87%AA+%40%E6%8E%A8%E9%85%B7%E7%BD%91%29&key=3113829255"); }); $("#share_qq_id").click( function() { window.open("http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.tuicool.com/articles/fqaqqmF&title=React+%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E5%9C%A8+React+%E9%87%8C%E9%9D%A2%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E7%9F%A5%E9%81%93%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B%2C+%E4%BD%86%E6%98%AF%E4%BD%A0%E4%BC%9A%E5%8F%91%E7%8E%B0%E4%BB%96%E4%BB%AC%E7%A1%AE%E5%AE%9E%E5%BE%88%E6%9C%89%E7%94%A8%EF%BC%89&desc=&summary=&site="); }); $("#share_weixin_id").click( function() { $("#share_weixin_image").toggle(); });</script>

<div class="bottom_plink clearfix">[![](http://static0.tuicool.com/images/upload/aliyun720.jpg)](http://click.aliyun.com/m/22453/)</div>

</div>

<div id="site_articles" style="clear:both;">

<div class="article-part-title"><span>推荐文章</span></div>

*   1. [用GraphQL增强React](/articles/RZni6fU "用GraphQL增强React")
*   2. [React实践填坑记](/articles/V7Zf2yA "React实践填坑记")
*   3. [H5 容器技术方案](/articles/J3QR3mr "H5 容器技术方案")
*   4. [react-native ListView下拉刷新上拉加载实现](/articles/vErMbaN "react-native ListView下拉刷新上拉加载实现")
*   5. [React-Navigation与Redux整合详解](/articles/m6zYbu2 "React-Navigation与Redux整合详解")
*   6. [react-native ListView组件点击跳转](/articles/ENraUnM "react-native ListView组件点击跳转")

</div>

<div id="article_weibo" style="display:none;">

<div class="article-part-title"><span>相关微博</span> <sub>[()](/articles/weibo_list/fqaqqmF)</sub></div>

</div>

<div class="comments">

<div class="comments-area">

<div class="comments-header">

##### 我来评几句

<div class="alert comment-alert alert-error" style="display:none;">错误</div>

<textarea cols="60" rows="5" id="comment-body" placeholder="请输入评论内容..." style="resize: none;"></textarea><span class="btn btn-medium btn-submit" id="comment-submit">登录后评论</span>

已发表评论数(<span class="comment_cnt"></span>)

</div>

<div class="comments-list">

<div class="empty-cmts alert alert-success" style="display:none;">没有更多评论了^^</div>

</div>

<div class="more-comments" style="display:none;"><a href="">更多评论</a></div>

<div class="load-fail" style="display:none;">评论加载失败，[重新加载](javascript:reload_comments('fqaqqmF',1,0,-1);)</div>

</div>

</div>

<div class="span4 article_right_side">

<div class="right_top">

<div class="article_related_site article_detail_bg">

#### 相关站点

<div class="article_related_site_body clearfix">

<div class="logo">![](http://stimg2.tuicool.com/y2QZR3m.png)</div>

<div class="name">

<div>[JohannLai's Blog](/sites/y2QZR3m)</div>

<div>

<div class="btn btn-success right_site_follow" id="my_follow" data_id="y2QZR3m">＋订阅</div>

</div>

</div>

</div>

</div>

<div id="right_site_articles" class="article_detail_bg">

<div class="article-part-title"><span>热门文章</span></div>

*   1. [React实践填坑记](/articles/V7Zf2yA "React实践填坑记")
*   2. [GitHub上最流行的Top 10 JavaScript项目](/articles/yQ3Efay "GitHub上最流行的Top 10 JavaScript项目")
*   3. [用GraphQL增强React](/articles/RZni6fU "用GraphQL增强React")
*   4. [H5 容器技术方案](/articles/J3QR3mr "H5 容器技术方案")
*   5. [React-Navigation与Redux整合详解](/articles/m6zYbu2 "React-Navigation与Redux整合详解")

</div>

</div>

<div class="operate_zone">

<div class="right-link" style="margin-top: 5px">[![](http://static0.tuicool.com/images/upload/aliyun311.jpg)](http://click.aliyun.com/m/17039/)</div>

<div class="right-link" style="margin-top: 0px">[![](http://static2.tuicool.com/images/upload/ksyun307.jpg)](http://activity.ksyun.com/1710/index.html?ch=00033.00018&hmsr=tk&hmpl=1710&hmcu=&hmkw=&hmci=)</div>

<div class="right-link" style="margin-top: 5px">[![](http://static0.tuicool.com/images/upload/meituan309.jpg)](https://www.mtyun.com/promote/75141963-dd40-400d-9b56-b5e0262001fd/?site=tuicool&campaign=20170401sales)</div>

</div>

</div>

<div>

<div id="add-article-to-kan" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">

<div class="modal-header"><span class="add-title">收藏到推刊</span> [创建推刊](#new-kan)</div>

<div class="modal-footer"><input value="fqaqqmF" class="article-id" type="hidden"> <button class="btn btn-primary pull-left add-to-btn"> 收 藏 </button> <button class="btn" data-dismiss="modal" aria-hidden="true" style="margin-right: 15px">取消</button></div>

</div>

<div id="new-kan" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">

<div class="modal-body"><input name="name" id="new-kan-name" placeholder="推刊名(必填)" required="" data-validation-required-message="请填写推刊名" type="text"> <span class="new-ness-name">请填写推刊名</span>
<textarea name="desc" id="desc" rows="6" placeholder="推刊描述"></textarea><span class="new-ness-desc">描述不能大于100个字符!</span>
权限设置：<input name="type" value="1" checked="checked" type="radio"> 公开 <input name="type" value="0" type="radio"> 仅自己可见</div>

<div class="modal-footer"><button class="btn btn-primary pull-left create-kan-btn" disabled="">创建</button> <button class="btn dismiss-new-kan" data-dismiss="modal" aria-hidden="true">取消</button></div>

</div>

</div>

<div id="article-correct-modal" class="modal hide fade in" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="false">

<div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-hidden="true">×</button>

### 文章纠错

</div>

<div class="modal-body"><input value="fqaqqmF" id="article-correct-source" type="hidden">

<div><label for="article-correct-email">邮箱地址</label> <input id="article-correct-email" class="input-large" type="email"></div>

<div><label for="article-correct-select">错误类型</label> <select id="article-correct-select"><option value="正文不准确">正文不准确</option> <option value="标题不准确">标题不准确</option> <option value="排版有问题">排版有问题</option> <option value="排版有问题">主题不准确</option> <option value="没有分页内容">没有分页内容</option> <option value="图片无法显示">图片无法显示</option> <option value="视频无法显示">视频无法显示</option> <option value="与原文不一致">与原文不一致</option></select></div>

<div><label for="article-correct-other">补充信息</label><textarea id="article-correct-other" class="span4"></textarea></div>

</div>

<div class="modal-footer"><button class="btn btn-primary pull-right huodong_correct_submit" id="article-correct-submit">  提交  </button></div>

</div>

<link rel="stylesheet" href="http://static0.tuicool.com/stylesheets/highlight.default.css">  <script type="text/javascript">$('table').each(function(i) { var size = $(this).children().size(); if (size > 1) { $(this).attr('class',"table table-bordered"); } else if (size == 1) { var e11 = $(this).children(":first"); var e1 = e11[0]; var name = e1.nodeName.toLowerCase(); if ("tbody" == name) { if (e1.children.length > 1) { $(this).attr('class',"table table-bordered"); } else if (e1.children.length == 1){ var e12 = e1.children[0]; var name2 = e12.nodeName.toLowerCase(); if ("tr" == name2) { if (e12.children.length > 1) { $(this).attr('class',"table table-bordered"); } } } } } }); related_kan("fqaqqmF"); window.page = 0; window.last = 0; window.first = true; resize_article_image('#nei', 550); load_comments("fqaqqmF",1,0,-1); window.uid = -1; open_add_article_to_kan("false"); async_do_zan_article(); $('pre').each(function(i, e) { hljs.highlightBlock(e, "<span class='indent'> </span>", false) }); handle_follow_site("#my_follow","已订阅","+ 订阅");</script>

<div class="footer">

<div class="footer-inner" style="padding-top: 50px;padding-bottom: 50px">[关于我们](http://www.tuicool.com/about) [移动应用](http://www.tuicool.com/mobile) [意见反馈](http://www.tuicool.com/bbs/go/issues) [官方微博](http://e.weibo.com/tuicool2012)</div>

</div>